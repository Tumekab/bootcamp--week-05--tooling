There are times when we may need to view or even work from the files in our older commits. Perhaps because we need to compare the code to fix something broken, or refer to older code to see how something worked before or to add it back in.
\\

Understanding how Git saves your changes can help you learn how to move between different versions more quickly and why something might be happening if you have unexpected results.


\section{Under the hood of Git}

\subsection{Git has integrity}

Git has a clever way of knowing if files have changed in any way, or if the files match an earlier snapshot.

\begin{itemize}
	\item Everything is check-summed before storage
	\item Snapshots are referred to by that checksum
	\item Impossible to change the contents of any file or directory without Git knowing about it because it will change the checksum
	\item Checksumming is SHA-1 hash, producing 40-character string e.g:
	\\
24b9da6552252987aa493b52f8696cd6d3b00373
\end{itemize}

\subsection{Git only adds data}

...mostly.
\\

It is hard to get the system to do anything that is not undoable or to make it erase data in any way.
\\

Actions in Git (nearly) only add data to the Git database.
\\

It is therefore a great safety net for trying things out, and rolling back if needed.
\\

After you commit a snapshot it is very difficult to lose work, especially if you regularly push to a remote repository.
\\

The only way you can lose or mess up changes is if you havenâ€™t pushed your work yet (see working with the remote), or use some more niche commands and arguments like \texttt{--force} (more on this later).
\\

\subsection{The HEAD}

\begin{infobox}{The HEAD (yes it's in capitals on purpose!)}
	The active commit you are currently working from. 
	\\
	
	Usually it is the last commit you made, but it can be an older commit if you moved to that.
\end{infobox}

When we move between commits we change the commit the HEAD refers to.
\\


\section{Commands for moving between commits}

\subsection{Commit hashes}

To move to a different commit, we need to find it's hash. The hash is automatically generated by Git and looks like this \textbf{166348d5901829380ab5b44ffa09fea3a595f64d}. 
\\

This is the checksum value that we referred to earlier.
\\

We can use the \texttt{git log} or \texttt{git reflog} command to get a list of the hashes. \texttt{git reflog} gives a shortened version of the hashes but they still work the same as the long ones.
\\

\subsection{Checking out older commits git checkout}

We can move to an older commit using:

\begin{minted}{bash}
    git checkout {commit hash}

    eg.
    git checkout 166348d5901829380ab5b44ffa09fea3a595f64d
    or
    git checkout 166348d
\end{minted}

Note that if you have unsaved changes or files you have not committed you will be prompted to save and commit before you move.
\\

\subsection{Return to the end of your commits}

To return to the very last commit you made (the tip of your series of commits), you can use:

\begin{minted}{bash}
    git checkout master

    or

    git switch -
\end{minted}

Don't use these commands blindly, especially as you get more advanced with Git and start using different branches. More to follow.
\\

Another option is to use \texttt{git reset}. This does a very similar thing and will return you to the tip (last commit) of whatever branch you are working on.

\begin{minted}{bash}
    git reset --hard HEAD
\end{minted}

Using the \texttt{--hard} flag resets the index and working tree. Any changes to tracked files in the working tree since your last commit are discarded.

\begin{minted}{bash}
    git reset --soft HEAD
\end{minted}

Using the \texttt{--soft} flag leaves all your changed files eg "changes to be committed" but moves your tree so you are working from your last commit.
\\

\subsection{Stashing unfinished work}

\texttt{git stash} temporarily shelves (or stashes) changes you've made to your working copy so you can work on something else, and then come back and re-apply them later on. 
\\

Stashing is handy if you need to quickly switch context and work on something else, but you're mid-way through a code change and aren't quite ready to commit.
\\

The downside with stashing is remembering that you stashed something. I nearly always forget what I stashed where so use this with caution. Like all things Git, you still have to know what's going on, a tool like Git doesn't solve all your workflow problems!
\\

\href{https://www.atlassian.com/git/tutorials/saving-changes/git-stash}{Atlassian article on stashing}

\section{Additional resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://en.wikipedia.org/wiki/Checksum}{Wikipedia: checksum}
	\item \href{https://eagain.net/articles/git-for-computer-scientists/}{Git for Computer Scientists (Quick introduction to git internals for people who are not scared by words like Directed Acyclic Graph)}
	\item \href{https://opensource.com/article/18/6/git-reset-revert-rebase-commands}{How to reset, revert and return to previous states in Git}
	\item \href{https://www.atlassian.com/git/tutorials/saving-changes/git-stash}{Atlassian article on stashing}
	\item \href{https://dev.to/srebalaji/useful-tricks-you-might-not-know-about-git-stash-117e}{Useful tricks you might not know about Git stash}
\end{itemize}


